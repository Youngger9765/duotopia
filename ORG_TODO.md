# 機構層級管理系統 - 商業策略與產品規劃

> **⚠️ 停！在談技術之前，先回答根本問題：**
>
> **為什麼要做機構功能？**
> - 因為機構才有決策權、才會來採購
> - 個體戶天花板太低，無法規模化成長
> - 需要切入 B2B 市場，才能做大

---

## 🎯 第一層：為什麼做機構？（商業價值）

### 現況問題

| 維度 | 個體戶市場（現在） | 機構市場（目標） |
|------|------------------|-----------------|
| **客戶** | 獨立教師、家教 | 補習班、學校、教育集團 |
| **定價** | $330/月/人 | $X萬/年（待定） |
| **決策者** | 老師自己 | 總部、教務處、採購組 |
| **銷售週期** | 短（即買即用） | 長（需簽約、採購流程） |
| **LTV** | 低（$330 × 12 = $3,960/年） | 高（一個機構 = 50-100 位老師） |
| **成長天花板** | 低（台灣獨立教師有限） | 高（一家補習班 > 100 個個體戶） |

### 商業目標

**短期目標（3-6 個月）**：
- [ ] 驗證機構市場需求（POC）
- [ ] 簽下第一個機構客戶（Pilot）
- [ ] 建立機構管理 MVP 功能

**中期目標（6-12 個月）**：
- [ ] 簽下 5-10 家機構
- [ ] 建立標準化銷售流程
- [ ] 完善機構管理功能

**長期目標（1-2 年）**：
- [ ] 機構收入佔比 > 50%
- [ ] 建立品牌（「XX 補習班都在用」）

---

## 🏢 第二層：賣給誰？（市場切入點）

### 市場選擇（待決定）

**選項 A：只做個體戶** ❌
- 優點：簡單、現有架構可用
- 缺點：天花板低、無法規模化
- 結論：不可行

**選項 B：只做機構** ⚠️
- 優點：高 LTV、規模化
- 缺點：現有個體戶用戶怎麼辦？需要遷移
- 結論：風險高

**選項 C：雙軌並行** ✅
- 優點：保留現有用戶、開拓新市場
- 缺點：產品複雜度提高
- 結論：**建議採用**

---

## 💰 第三層：為什麼買？（價值主張）

### 🔍 Duotopia 在 AI 時代的獨特價值

**我們不是 Duolingo（B2C 個人學習）**
- Duolingo: 個人自學，$29.99/月
- ❌ 沒有老師介入
- ❌ 無法追蹤班級進度
- ❌ 不符合台灣補習班/學校需求

**我們是「AI + 真人老師」的 B2B2C 模式**
- 🎯 目標：補習班、學校（B2B）
- 👨‍🏫 使用者：老師、學生（B2C）
- 💡 定位：**老師的 AI 助教平台**

---

### 💎 核心價值主張（基於市場研究）

#### 對機構（決策者）的價值

**1. 降低人力成本**
- 現況：老師批改作業耗時 40-60%
- 價值：AI 自動批改 → 老師可以多教 1.5-2 倍學生
- ROI：假設一位老師年薪 60 萬，節省 40% 時間 = **節省 24 萬/年**

**2. 標準化品質控管**
- 現況：各分校教學品質不一致
- 價值：統一教材、統一評分標準
- 結果：家長滿意度提升 → 續班率提高

**3. 數據驅動決策**
- 現況：不知道哪個分校、哪位老師、哪個學生需要幫助
- 價值：總部可看所有數據（Dashboard）
- 結果：精準調配資源、提升教學效果

**4. 降低老師流動風險**
- 現況：老師離職 → 學生流失
- 價值：教材、學生進度都在系統上
- 結果：換老師不影響教學連續性

#### 對老師（使用者）的價值

**1. 省時間**
- 不用手動批改 → 省下 40-60% 時間
- 自動產生學習報告 → 家長溝通更輕鬆

**2. 更專業**
- AI 提供標準化評分
- 數據化追蹤學生進度
- 證明教學成效

**3. 更有競爭力**
- 使用 AI 工具的老師 > 傳統老師
- 提升個人價值

---

### 📊 市場定位與競爭優勢

| 維度 | Duolingo | ELSA/TalkMe | **Duotopia** |
|------|----------|-------------|--------------|
| **目標市場** | B2C 個人 | B2C 個人 | **B2B 機構** |
| **使用場景** | 自學 | 自學 | **課堂教學** |
| **老師角色** | 無 | 無 | **核心** |
| **班級管理** | ❌ | ❌ | **✅** |
| **作業指派** | ❌ | ❌ | **✅** |
| **進度追蹤** | 個人 | 個人 | **班級+機構** |
| **定價模式** | $29.99/月/人 | $10-20/月/人 | **$X/月/老師** |
| **台灣市場** | 弱（自學文化弱） | 弱 | **強（補習文化強）** |

**Duotopia 的護城河**：
1. ✅ **唯一專注 B2B 教育機構**（Duolingo 做不了）
2. ✅ **深度整合台灣補習班流程**（國際產品不懂）
3. ✅ **老師 + AI 雙軌**（純 AI 做不到人性化）
4. ✅ **班級管理 + 作業系統**（ELSA 沒有）

---

### 🎯 定價策略思考（基於市場研究）

**參考基準**：
- 學生年支出：$36,000-$52,000/年
- ChatGPT Enterprise：$60/年/人（最少 150 人）
- Duolingo Max：$29.99/月 = $360/年

**Duotopia 定價邏輯**：

**方案 A：按老師數計費**
- 小班制補習班：1 老師 : 20 學生
- 假設定價：$500/月/老師 = $6,000/年
- 分攤到學生：$300/年/學生（< $36,000 的 1%）
- 對機構：節省老師 24 萬/年，花 6,000 → **ROI = 40 倍**

**方案 B：按學生數計費**
- 定價：$20/月/學生 = $240/年
- 對家長：$240 < $36,000 的 1%（可接受）
- 對機構：100 學生 = $24,000/年（可分攤給家長）

**方案 C：固定費用（不限人數）**
- 定價：$30,000-$50,000/年（中小型補習班）
- 適合：10-20 位老師的機構
- 優點：簡單、不用算人頭

### ❓ 待驗證的問題

1. **機構真的有這些痛點嗎？**（需要訪談）
2. **我們的解決方案夠強嗎？**（需要 Demo）
3. **定價多少機構才會買？**（需要測試）
4. **誰是決策者？誰是使用者？**（總部 vs 老師）
5. **ROI 計算合理嗎？**（節省 24 萬 vs 花 6,000）

---

## 🎨 第四層：怎麼做？（產品規劃）

### 目標客戶畫像（待確認）

**優先級 1：中小型補習班**
- 規模：3-10 位老師，1-3 個校區
- 特徵：老闆親自管理，決策快
- 痛點：想要數位化，但不想花大錢
- 定價敏感度：高

**優先級 2：大型連鎖補習班**
- 規模：50+ 位老師，5+ 個校區
- 特徵：有教務總監，決策慢
- 痛點：品質管控、數據追蹤
- 定價敏感度：中

**優先級 3：私立學校**
- 規模：20-50 位老師
- 特徵：採購流程複雜
- 痛點：教學創新、家長滿意度
- 定價敏感度：低

### 關鍵問題（必須先回答）

#### 🔴 商業策略層
1. **第一個目標客戶是誰？**
   - 中小型補習班？大型連鎖？私校？公校？

2. **定價策略**
   - 按老師數？按學生數？按校區數？
   - 一次性買斷？年約？月約？

3. **銷售模式**
   - 直銷（自己賣）？代理商？線上自助？

#### 🟡 產品功能層（在回答上述問題後才討論）
4. **機構管理員需要什麼功能？**
   - 看所有分校進度？
   - 管理老師帳號？
   - 看學生學習報告？

5. **老師的使用體驗會改變嗎？**
   - 介面一樣？還是會多一些「機構」相關功能？

6. **獨立老師要如何無痛升級？**
   - 自動建立「個人機構」？
   - 還是維持原樣？

---

## 📝 決策清單（必須先回答才能往下）

### 🔴 Tier 1：商業模式（最高優先）

**Q1. 第一個目標客戶是誰？**
- [ ] 中小型補習班（3-10 位老師）
- [ ] 大型連鎖補習班（50+ 位老師）
- [ ] 私立學校
- [ ] 公立學校
- [ ] 其他：____________

**Q2. 定價策略是什麼？**
- [ ] 按老師數計費（$X/月/老師）
- [ ] 按學生數計費（$X/月/學生）
- [ ] 按校區數計費（$X/月/校區）
- [ ] 固定費用（不管規模）
- [ ] 其他：____________

**Q3. 合約模式？**
- [ ] 月約（隨時可取消）
- [ ] 年約（一次付清，優惠）
- [ ] 買斷（一次性付費）

**Q4. 銷售方式？**
- [ ] 直銷（自己賣，需要業務團隊）
- [ ] 線上自助（機構自己註冊購買）
- [ ] 代理商/經銷商
- [ ] 混合模式

---

### 🟡 Tier 2：產品定位（在 Tier 1 確認後）

**Q5. 機構管理員的核心需求是什麼？**（最重要的 3 個功能）
- [ ] 1. ____________
- [ ] 2. ____________
- [ ] 3. ____________

**Q6. 老師的使用體驗會如何變化？**
- [ ] 完全不變（對老師透明）
- [ ] 小幅調整（多一些機構相關資訊）
- [ ] 大幅改變（全新介面）

**Q7. 獨立老師如何升級到機構？**
- [ ] 自動建立「個人機構」（所有人都在機構架構下）
- [ ] 維持原樣，有需要再手動升級
- [ ] 其他：____________

---

### 🟢 Tier 3：技術實作（在 Tier 1 & 2 確認後才討論）

**Q8. 資料隔離方式？**
- [ ] Row Level Security (RLS)
- [ ] 每個機構獨立資料庫
- [ ] Schema-based isolation

**Q9. 遷移策略？**
- [ ] 大爆炸遷移（一次改完）
- [ ] 分階段遷移（Phase 1/2/3）
- [ ] 雙軌並行（新舊系統共存）

---

## ⏸️ 暫時擱置的技術討論

> **注意**：以下技術討論在商業策略確認前，暫時不討論。
>
> 原因：
> - 不知道目標客戶 → 不知道要做哪些功能
> - 不知道定價模式 → 不知道要支援哪些限制
> - 不知道銷售方式 → 不知道 Onboarding 流程

<details>
<summary>展開舊的技術討論（暫時擱置）</summary>

### ✅ 已確認的商業邏輯

1. **基本架構**
   ```
   Organization (機構)
     └── School (校區)
          ├── Teachers (老師們)
          ├── Classrooms (班級們)
          └── Students (學生們，透過班級歸屬)
   ```

2. **老師可以跨校區**（同機構內）
   - 例如：補習班老師在台北、新竹兩個校區教課
   - 需要決定：同帳號切換？還是多帳號？

3. **協同教學限制**
   - 只能邀請「同機構 + 同校」的老師
   - 不能跨校區、不能跨機構

4. **學生透過班級歸屬**
   - 學生加入班級 → 班級屬於學校 → 學校屬於機構
   - 不需要 `school_students` 直接關聯

5. **獨立老師 = 自動建立個人機構**
   - 所有老師都是「機構」架構
   - 獨立老師只是「單人機構」
   - UI 根據 role 動態顯示功能

---

### ❓ 待釐清的商業邏輯

#### A. 定義與命名

**A1. Organization 的定義**
- [ ] 補習班總部（如：均一教育平台）
- [ ] 學校法人
- [ ] 個人品牌（如：王老師教育工作室）
- [ ] 其他：____________

**A2. School 的定義**
- [ ] 分校（補習班的台北分校、新竹分校）
- [ ] 校區（大學的校本部、分部）
- [ ] 實體學校（台北市XX國小）
- [ ] 其他：____________

**A3. 獨立老師的 School**
- [ ] 需要自動建立一個 School（叫「預設校區」？）
- [ ] 不需要 School，Classroom 直接屬於 Organization
- 💡 **建議**：需要，統一架構，叫「主校區」或留空

---

#### B. 跨校區/跨機構

**B1. 老師跨校區（同機構內）**

情境：王老師在 ABC 補習班，同時在台北、新竹教課

- [ ] **方案 A**：同一個帳號，可切換校區
  - UI 有「切換校區」下拉選單
  - 班級列表依校區分組顯示

- [ ] **方案 B**：兩個獨立帳號
  - 台北一個帳號，新竹一個帳號
  - Email 可以相同（因為在同機構內）

**B2. 老師跨機構**

情境：王老師在 ABC 補習班教英文，也在 XYZ 補習班教數學

- [ ] **方案 A**：同一個帳號，可切換機構
  - 資料隔離問題：ABC 的學生資料被 XYZ 看到？
  - 帳務問題：誰付費？

- [ ] **方案 B**：兩個獨立帳號（推薦）
  - ABC 一個帳號，XYZ 一個帳號
  - 完全隔離（資料、權限、帳務）

💡 **建議**：選 B（多帳號），理由：
- 資料隔離（安全性）
- 帳務清楚（各付各的）
- 業界慣例（Google Workspace, Slack）

**B3. 學生跨機構**

情境：小明在 ABC 補習班上英文，在 XYZ 補習班上數學

- [ ] **方案 A**：同一個帳號
- [ ] **方案 B**：兩個獨立帳號（推薦）

目前登入方式：老師 email + 學號 + 密碼
未來可能：機構代碼 + 學號 + 密碼

---

#### C. 角色與權限

**C1. 老師角色**

| 角色 | 權限範圍 | 主要功能 |
|------|---------|---------|
| `teacher` | 自己的班級 | 管理班級、學生、作業 |
| `school_admin` | 該校區 | ？管理老師？查看所有班級？ |
| `org_admin` | 整個機構 | 管理分校、老師、訂閱 |

**待確認**：
- [ ] `school_admin` 可以編輯其他老師的班級嗎？
- [ ] `org_admin` 可以直接管理班級嗎？

**C2. 協同老師權限**

| 權限 | owner | co_teacher | assistant |
|------|-------|-----------|-----------|
| 編輯班級資訊 | ✅ | ？ | ❌ |
| 新增/移除學生 | ✅ | ？ | ❌ |
| 指派作業 | ✅ | ✅ | ？ |
| 批改作業 | ✅ | ✅ | ✅ |
| 邀請其他老師 | ✅ | ❌ | ❌ |

**待確認**：標記 ？ 的部分

---

#### D. 金流與訂閱

**D1. 訂閱層級**

- [ ] **機構層級**：ABC 補習班付一筆，涵蓋所有分校
- [ ] **學校層級**：台北分校付一筆，新竹分校付一筆
- [ ] **老師層級**：每個老師各自付費

💡 **建議**：機構層級（統一管理）

**D2. 跨校區老師的計費**

王老師在台北、新竹兩個校區：

- [ ] 算 1 人（同一個帳號）
- [ ] 算 2 人（兩個授課地點）

**D3. 方案限制（初步想法）**

| 方案 | 月費 | 校區 | 老師 | 學生 |
|------|------|------|------|------|
| Free | $0 | 1 | 3 | 100 |
| Basic | $299 | 3 | 20 | 500 |
| Premium | $999 | 10 | 50 | 2000 |
| Enterprise | 議價 | ∞ | ∞ | ∞ |

**待確認**：
- [ ] 限制數字合理嗎？
- [ ] 超過限制怎麼辦？封鎖？提示升級？

---

#### E. 升級路徑

**E1. 獨立老師升級觸發時機**

- [ ] 當想邀請第二位老師時
- [ ] 當想建立第二個校區時
- [ ] 當學生數超過 100 時
- [ ] 其他：____________

**E2. 升級後的差異**

- UI：多了「機構管理」、「分校管理」、「老師管理」選單
- 功能：可以邀請老師、建立分校
- 訂閱：改用機構計費

**待確認**：
- [ ] 升級需要付費嗎？
- [ ] 還是只是「解鎖功能」？

</details>

---

## 💭 思考筆記（持續更新）

### 2025-11-26 (深夜 23:00)：完整情境評估與風險分析

**重新評估**：方案能否應對所有真實情境？

#### 🚨 發現的三大核心風險

**風險 1：權限系統設計不足** 🔴 高
```
當前設計：
teachers 表只有 organization_id（歸屬）
缺少：role（角色）、permissions（權限）

無法支援的情境：
❌ 夫妻檔工作室：老公能看到老婆的學生資料嗎？
❌ 補習班班主任：想看所有老師進度，但其他老師不能互看
❌ 公立學校：30 位老師，彼此資料需要隔離
❌ 教務主任：不教課，但要管理所有老師
❌ 行政人員：需要協助管理，但權限受限

結論：必須在 Phase 1 就設計基礎權限架構
```

**風險 2：資料隔離機制脆弱** 🔴 高
```
當前設計：
依賴開發者記得寫 WHERE organization_id = current_user.org_id

風險：
🔴 一個 bug 就可能洩漏其他組織的資料
🔴 新加入的工程師可能忘記加過濾條件
🔴 複雜查詢容易漏掉隔離邏輯

真實案例：
2019 年某 SaaS 公司因為少寫一個 WHERE，
導致客戶 A 看到客戶 B 的資料 → 巨額賠償

建議：
✅ PostgreSQL Row Level Security (RLS)
✅ 或在 ORM 層自動過濾（global scope）
✅ 絕不能依賴「記得寫」
```

**風險 3：組織內隱私控制不足** 🔴 高
```
情境：公立學校（30 位英文老師）
需求：
- 老師之間不能看到彼此的班級資料
- 但教務主任要能看到所有資料

當前設計：
teachers 都在同一個 organization
→ 無法區分「老師 vs 老師」的隔離

問題：
❌ organization 層級的隔離太粗
❌ 需要更細粒度的權限控制
❌ 可能需要重新思考「organization」的定義

兩難：
方案 A：每個老師都是獨立 organization
  → 失去「學校」的概念
  → 無法做學校層級的統計

方案 B：在 organization 內加權限控制
  → 複雜度提高
  → 但更符合真實需求
```

---

#### 📊 完整情境評估矩陣

| 客戶類型 | 當前支援度 | 主要問題 |
|---------|-----------|---------|
| 獨立教師 | ✅ 100% | 無 |
| 夫妻檔工作室 | ⚠️ 70% | 權限控制 |
| 小型補習班 | ⚠️ 60% | 角色分級 |
| 連鎖補習班 | ⚠️ 50% | 多層級權限 |
| 公立學校 | ❌ 30% | 組織內隔離 |
| 協同教學 | ⚠️ 60% | UX 複雜 |
| 學生轉學 | ⚠️ 50% | 跨組織遷移 |
| 方案升級 | ⚠️ 70% | 計費轉換 |
| 機構合併 | ⚠️ 40% | 資料遷移 |
| GDPR 合規 | ❌ 30% | 資料治理 |

**平均支援度**：57%（勉強及格）

---

#### 🛠️ 必須補強的設計

**1. 權限系統（Phase 1 必須）**
```sql
-- 方案 A：簡單 role（建議先用這個）
teachers 表：
  role VARCHAR DEFAULT 'teacher'
  -- "owner", "admin", "teacher", "staff"

-- 方案 B：細粒度權限（Phase 2）
CREATE TABLE permissions (
  teacher_id,
  resource_type VARCHAR,  -- "classroom", "student", "analytics"
  resource_id UUID,       -- 特定資源 ID
  action VARCHAR          -- "view", "edit", "delete"
);
```

**2. 資料隔離機制（Phase 1 必須）**
```sql
-- 使用 PostgreSQL RLS
ALTER TABLE classrooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY org_isolation ON classrooms
FOR ALL
TO authenticated
USING (
  school_id IN (
    SELECT id FROM schools
    WHERE organization_id = current_setting('app.current_org_id')::uuid
  )
);
```

**3. 組織內隱私控制（Phase 2）**
```sql
-- 老師只能看自己的班級（除非是 admin）
CREATE POLICY teacher_own_classrooms ON classrooms
FOR ALL
TO authenticated
USING (
  created_by = current_setting('app.current_teacher_id')::uuid
  OR
  current_setting('app.teacher_role') IN ('owner', 'admin')
);
```

---

### 2025-11-26 (深夜 21:00)：三大核心需求驗證

**驗證問題**：萬用架構能否支援以下需求？

#### ✅ 需求 1：協同教學（一班多師）

**可行性**：✅ 可以做到

**技術方案**：
```sql
CREATE TABLE classroom_teachers (
  classroom_id, teacher_id, role VARCHAR
);
-- role: "owner", "co_teacher", "assistant"

-- 遷移現有資料
INSERT INTO classroom_teachers (classroom_id, teacher_id, role)
SELECT id, teacher_id, 'owner' FROM classrooms;
```

**回滾方式**：DROP TABLE classroom_teachers

**複雜度**：🟡 中等（需要測試，但可回滾）

---

#### ✅ 需求 2：老師跨組織（確定方案）

**決定**：✅ **採用多帳號模式**（就像換公司會有新 email）

**設計原則**：
```
老師 = 組織的資源
就像員工 = 公司的資源

換組織 = 新帳號
├── 王老師 @ ABC 補習班 → wang@abc.com (或 wang+abc@gmail.com)
└── 王老師 @ XYZ 補習班 → wang@xyz.com (或 wang+xyz@gmail.com)
```

**資料庫設計**：
```sql
teachers 表：
  id UUID PRIMARY KEY
  organization_id UUID NOT NULL  -- 強制歸屬
  email VARCHAR NOT NULL

UNIQUE (organization_id, email)  -- 同組織內 email 唯一
```

**好處**：
- ✅ 資料完全隔離（安全第一）
- ✅ 帳務清楚（ABC 付 ABC 的，XYZ 付 XYZ 的）
- ✅ 權限簡單（每個組織獨立管理）
- ✅ 業界慣例（Google Workspace, Slack, GitHub）
- ✅ 架構簡單（不需要複雜的跨組織權限邏輯）

**不做的功能**：
- ❌ 單一帳號跨多組織
- ❌ teacher_organizations 多對多表
- ❌ 複雜的 context switching（切換組織）

**未來擴展**（如果真的有需求）：
```sql
-- 可以用 email 當連結，但帳號仍獨立
SELECT * FROM teachers WHERE email = 'wang@gmail.com'
→ 找到同一人在不同組織的所有帳號
→ 但系統內仍是獨立的 teacher records
```

---

#### ✅ 需求 3：課程共享與複製

**可行性**：✅ 現有架構已支援

**技術實作**：
```sql
-- 已有欄位
programs.source_type = "template" | "classroom" | "custom"
programs.source_metadata = {
  "template_id": 123,
  "classroom_id": 456,
  "teacher_name": "王老師"
}
```

**使用情境**：
1. **機構公版課程**：is_template=True, classroom_id=NULL
2. **老師分享課程**：source_type="classroom"
3. **複製並修改**：保留來源資訊在 source_metadata

**權限控制**：
- 自己的課程：永遠可複製
- 機構公版：同機構內可複製
- 他人課程：機構設定允許時可複製

**複雜度**：🟢 低（只需加 UI，後端邏輯已有）

---

### 2025-11-26 (晚上)：萬用解法 - 最小成本方案

**問題**：商業策略未定，但需要開始開發

**解答**：**「軟性機構」架構 - 所有人都在機構架構下**

#### 核心設計原則

**1. 延遲決策（Defer Decision）**
- 不要現在就決定定價、目標客戶
- 建立一個可以 fit 所有情境的架構
- 未來根據市場反應調整

**2. 向後相容（Backward Compatible）**
- 現有用戶 100% 無感
- 自動遷移（不需要手動操作）
- API 保持不變

**3. 彈性擴展（Flexible Scale）**
- 獨立老師 → 小型機構 → 大型機構
- 1 人 → 多人 → 多校區
- 無需改架構，只需要「加人」

#### 技術方案：「萬用機構架構」

```
所有 Teacher 自動屬於一個 Organization
├── 獨立老師：organization.type = "personal"（1 人機構）
├── 小型機構：organization.type = "small"（2-10 人）
└── 大型機構：organization.type = "enterprise"（10+ 人）

所有 Classroom 自動屬於一個 School
├── 獨立老師：school.name = teacher.name（個人工作室）
├── 單一學校：school.name = organization.name
└── 多校區：school.name = "台北分校", "新竹分校"
```

**關鍵**：
- 不用 `is_solo_mode`, `is_default` 等 flag
- 只用 `organization.type` 和實際資料（老師數、校區數）
- UI 根據資料動態顯示功能

#### MVP 實作策略（3 階段 + 回滾機制）

**Phase 1: 資料遷移（0 風險，可回滾）**

**遷移腳本**：
```sql
-- 1. 新增表（可刪除）
CREATE TABLE organizations (id, name, type, created_at);
CREATE TABLE schools (id, organization_id, name, created_at);

-- 2. 加欄位（nullable = 可回滾）
ALTER TABLE teachers ADD COLUMN organization_id UUID NULL;
ALTER TABLE classrooms ADD COLUMN school_id UUID NULL;

-- 3. 自動遷移（保留原始資料）
FOR EACH teacher:
  org = CREATE organization (name = teacher.name, type = "personal")
  school = CREATE school (org_id = org.id, name = teacher.name)
  UPDATE teacher SET organization_id = org.id  -- 不刪除原資料
  UPDATE classrooms SET school_id = school.id WHERE teacher_id = teacher.id
  -- ⚠️ teacher_id 欄位保留！不刪除！
```

**回滾策略**：
```sql
-- 如果發現有問題，一鍵回滾
ALTER TABLE teachers DROP COLUMN organization_id;
ALTER TABLE classrooms DROP COLUMN school_id;
DROP TABLE schools;
DROP TABLE organizations;

-- 原始資料完全不受影響（teacher_id 還在）
```

**安全措施**：
- ✅ 新欄位都是 `nullable`（不影響現有查詢）
- ✅ 舊欄位全部保留（teacher_id, classroom.teacher_id）
- ✅ API 完全不改（仍然用舊欄位查詢）
- ✅ 可隨時回滾（DROP 新表、DROP 新欄位）

**影響**：無，現有 API 完全不變

---

**Phase 2: API 調整（低風險，可回滾）**

**雙軌並行策略**：
```python
# 舊 API 保持不變（永久保留）
GET /api/classrooms?teacher_id=123
# → 查詢邏輯：WHERE teacher_id = 123
# → 現有客戶端完全不受影響

# 新 API（逐步啟用）
GET /api/organizations/{org_id}/classrooms
# → 查詢邏輯：WHERE school.organization_id = org_id
# → 只有新客戶使用

# 前端判斷（Feature Flag）
if (FEATURE_FLAG.organization_mode && organization.type != "personal"):
    show_organization_layout()  # 新介面
else:
    show_teacher_layout()  # 現有介面（預設）
```

**回滾策略**：
```python
# 1. 關閉 Feature Flag
FEATURE_FLAG.organization_mode = False

# 2. 所有人回到舊介面
# 3. 新 API 停止使用（但不刪除，保留 code）
```

**安全措施**：
- ✅ 舊 API 永不刪除（現有客戶端持續運作）
- ✅ Feature Flag 控制（可隨時關閉新功能）
- ✅ 雙軌並行（新舊系統同時存在）
- ✅ 灰度發佈（先給特定用戶測試）

**影響**：現有用戶看不到變化，新功能逐步開放

**回滾風險**：🟢 極低（關閉 Feature Flag 即可）

---

**Phase 3: 功能擴展（按需開發，模組化可回滾）**

根據第一個付費客戶的需求，再決定：
- 需要多校區？→ 開發校區管理
- 需要權限控管？→ 開發 role system
- 需要數據看板？→ 開發 dashboard

**模組化設計**：
```python
# 每個新功能都是獨立模組
FEATURE_FLAGS = {
    "multi_school": False,      # 多校區管理
    "role_management": False,   # 權限控管
    "analytics_dashboard": False # 數據看板
}

# 可隨時開關
if FEATURE_FLAGS["multi_school"]:
    enable_school_management()
```

**回滾策略**：
- 關閉對應 Feature Flag
- 功能立即停用
- 不影響其他功能

**不需要現在就全做！**

---

#### 🛡️ 完整回滾保證

| 階段 | 回滾難度 | 回滾方式 | 資料損失風險 |
|------|---------|---------|------------|
| **Phase 1** | 🟢 極低 | DROP 新表、DROP 新欄位 | 🟢 零風險（舊資料保留） |
| **Phase 2** | 🟢 極低 | 關閉 Feature Flag | 🟢 零風險（雙軌並行） |
| **Phase 3** | 🟢 極低 | 關閉模組 Feature Flag | 🟢 零風險（模組化設計） |

**最壞情況**：
```sql
-- 一鍵回滾腳本（5 秒內完成）
BEGIN;
ALTER TABLE teachers DROP COLUMN organization_id;
ALTER TABLE classrooms DROP COLUMN school_id;
DROP TABLE schools CASCADE;
DROP TABLE organizations CASCADE;
COMMIT;

-- 系統回到改動前狀態，所有用戶正常運作
```

**保證**：
- ✅ 任何時候都可以 100% 回滾
- ✅ 現有用戶完全不受影響
- ✅ 不會有資料損失
- ✅ 5 秒內恢復正常

#### 定價彈性（支援所有方案）

資料結構設計：
```sql
CREATE TABLE subscriptions (
  id,
  organization_id,
  plan_type VARCHAR,  -- "personal", "small", "enterprise"
  billing_model VARCHAR,  -- "per_teacher", "per_student", "fixed"
  price_per_unit INT,
  quota_teachers INT,
  quota_students INT,
  quota_schools INT,
  ...
);
```

**好處**：
- 可以隨時改定價方案
- A 機構按老師數計費
- B 機構按學生數計費
- C 機構固定費用
- 都用同一套系統！

---

### 2025-11-26 (下午)：市場研究與價值定位

**台灣教育市場規模**：
- 💰 補習班市場：**1,000-1,500 億台幣/年**
- 🏫 補習班數量：**16,000-18,000 家**（3倍便利商店數量）
- 👨‍🎓 參與率：70% 學生上補習班（國中 60%、高中 33%）
- 💸 年支出：每位學生 **$36,000-$52,000/年**

**全球 AI 教育市場**：
- 📈 2024: **$4.8-5.88 億美元**
- 🚀 2033-2034: **$72-112 億美元**
- 📊 年增長率：**31-36% CAGR**
- 🌍 EdTech 總支出 2025: **$404 億美元**

**競品參考定價**：
- Duolingo Max: **$29.99/月**（個人用戶，AI 功能）
- ELSA Speak: AI 發音評測
- ChatGPT Enterprise: **$60/年/人**（最少 150 人）

**AI 教師工具的價值**：
- ⏱️ 自動批改：節省老師 40-60% 批改時間
- 📝 AI 評分：即時反饋、標準化評分
- 📊 數據追蹤：學習進度可視化

---

### 2025-11-26 (上午)：重新定義問題

**發現**：我一開始就搞錯了重點。

- ❌ 我在想：「如何設計資料表？如何做多租戶？」
- ✅ 應該想：「為什麼要做機構功能？要賣給誰？」

**根本問題**：
1. 個體戶市場天花板太低（$330/月 × 有限的獨立教師）
2. 機構市場才有規模（一家補習班 = 50-100 位老師）
3. 決策權在機構，不在個別老師

**下一步**：
- 先確認商業策略（目標客戶、定價、銷售方式）
- 再決定產品功能（機構管理員要什麼？）
- 最後才談技術實作（資料表、API、UI）

---

## 🏗️ 技術現況（改動成本評估）

### 現有資料表結構

```sql
-- ✅ 已有預留欄位
classrooms (
    school VARCHAR(255),        -- 預留，未使用
    grade VARCHAR(50),           -- 預留，未使用
    academic_year VARCHAR(20),   -- 預留，未使用
    teacher_id INTEGER           -- 1:1 關係
)

-- ❌ 無預留
teachers (
    -- 沒有 organization_id, school_id, role
)

students (
    -- 沒有 organization_id
)
```

### 需要的改動（最小化方案）

#### Phase 1: 新增表（不影響現有）

```sql
CREATE TABLE organizations (...);
CREATE TABLE schools (...);
```

**影響**：無，新增表不影響現有功能

---

#### Phase 2: 加欄位（nullable，向下相容）

```sql
ALTER TABLE teachers ADD COLUMN organization_id UUID;
ALTER TABLE teachers ADD COLUMN school_id UUID;  -- 或用多對多
ALTER TABLE teachers ADD COLUMN role VARCHAR(20) DEFAULT 'teacher';

ALTER TABLE classrooms ADD COLUMN school_id UUID;
ALTER TABLE classrooms RENAME COLUMN school TO school_name;

ALTER TABLE students ADD COLUMN organization_id UUID;
```

**影響**：
- ✅ 現有資料：欄位為 NULL，功能不變
- ✅ 現有 API：查詢邏輯不變（WHERE teacher_id = X）
- ✅ 現有 UI：完全不變

---

#### Phase 3: 多對多關聯（最大改動）

```sql
-- 班級-老師多對多（協同教學）
CREATE TABLE classroom_teachers (
    classroom_id INTEGER,
    teacher_id INTEGER,
    role VARCHAR(20),
    ...
);

-- 遷移現有資料
INSERT INTO classroom_teachers (classroom_id, teacher_id, role)
SELECT id, teacher_id, 'owner' FROM classrooms;

-- 改名（保留建立者資訊）
ALTER TABLE classrooms RENAME COLUMN teacher_id TO created_by;
```

**影響**：
- ⚠️ API 需要調整：`classroom.teacher_id` → `classroom.created_by`
- ⚠️ 或加 property：`classroom.primary_teacher`
- ✅ 功能：向下相容，原本的「單一老師」變成「owner」

**風險評估**：中等（需測試）

---

### 改動成本總結

| 階段 | 改動 | 風險 | 影響範圍 |
|------|------|------|---------|
| Phase 1 | 新增 organizations, schools | 🟢 低 | 無影響 |
| Phase 2 | 加 nullable 欄位 | 🟢 低 | 無影響 |
| Phase 3 | classroom_teachers 多對多 | 🟡 中 | API 調整 |

**總評**：改動成本可控，關鍵是 Phase 3 需謹慎測試

---

## 🎯 使用情境範例

### 情境 1：ABC 補習班（中型機構）

```
ABC 補習班（Organization）
  ├── 台北校區（School）
  │    ├── 王老師（英文）
  │    ├── 李老師（數學）
  │    └── 班級：國小英文班、國中數學班
  │
  └── 新竹校區（School）
       ├── 王老師（英文，跨校區）
       ├── 陳老師（數學）
       └── 班級：國小英文班、國中數學班
```

**待釐清**：
- 王老師跨兩校區，同帳號？還是兩帳號？
- 台北的班級可以邀請新竹的老師協同嗎？（答案應該是：不行）

---

### 情境 2：XX 國小（公立學校）

```
XX 國小（Organization？）
  └── （需要 School 嗎？）
       ├── 五年A班（導師：王老師 + 音樂老師協同）
       └── 五年B班（導師：李老師）
```

**待釐清**：
- 公立學校算「機構」還是「學校」？
- 音樂老師跨班教學算協同教學嗎？

---

### 情境 3：王老師個人工作室（獨立老師）

```
王老師個人工作室（Organization）
  └── ？？？（自動建立 School？）
       └── 班級：國小英文班、國中數學班
```

**待釐清**：
- 需要自動建立 School 嗎？
- 如果需要，UI 要顯示嗎？還是隱藏？

---

## 📝 決策清單（需要回答）

### 🔴 高優先級（影響架構）

1. **老師跨校區**：同帳號 or 多帳號？
2. **老師跨機構**：同帳號 or 多帳號？
3. **學生跨機構**：同帳號 or 多帳號？
4. **獨立老師的 School**：需要 or 不需要？
5. **訂閱層級**：機構 or 學校 or 老師？

### 🟡 中優先級（影響功能）

6. **school_admin 權限**：可以做什麼？
7. **協同老師權限**：co_teacher vs assistant 的差異？
8. **協同教學範圍**：同校 or 同機構？
9. **方案限制**：Free/Basic/Premium 的數字？

### 🟢 低優先級（細節）

10. **升級觸發時機**：何時提示升級？
11. **超量處理**：封鎖 or 提示 or 自動升級？
12. **命名**：Branch vs School？預設校區 vs 主校區？

---

## 🚀 下一步（修正版：商業策略延後決定）

### ✅ Step 0: 建立萬用架構（當前階段）

**目標**：建立最小成本、最大彈性的技術架構
- [x] 定義「軟性機構」架構原則
- [x] 設計向後相容的遷移策略
- [x] 設計完整回滾機制
- [ ] 實作 Phase 1: 資料表 + 自動遷移
- [ ] 測試回滾腳本（確保可回滾）
- [ ] 驗證現有用戶無感

**產出**：
- 所有用戶自動遷移到「機構」架構
- 現有功能 100% 保持不變
- 為未來擴展打好基礎
- **任何時候都可以無痛回滾**

**安全保證**：
- 🛡️ 舊欄位全部保留（teacher_id 不刪除）
- 🛡️ 新欄位都是 nullable（可隨時刪除）
- 🛡️ API 完全不變（雙軌並行）
- 🛡️ Feature Flag 控制（可隨時關閉）
- 🛡️ 5 秒內完整回滾

**時程**：1-2 週

---

### ⏭️ Step 1: 尋找第一個付費客戶（邊做邊學）

**目標**：用 MVP 驗證市場需求
- [ ] 架構準備好後，開始銷售
- [ ] 找 1-2 家補習班/學校試用（免費或超低價）
- [ ] 根據客戶需求，決定 Phase 2 做什麼

**問題清單**（客戶訪談）：
1. 你們最大的痛點是什麼？
2. 願意為解決方案付多少錢？
3. 決策流程是什麼？（誰決定、誰付費）
4. 需要什麼功能？（機構管理員、老師、學生）

**產出**：
- 確認目標客戶畫像
- 確認定價策略
- 確認 MVP 功能清單

**時程**：1-2 個月

---

### ⏭️ Step 2: 快速開發客製功能（按需開發）

**目標**：根據第一個客戶需求，實作 Phase 2/3

**可能的功能（依客戶需求決定）**：
- [ ] 多校區管理？
- [ ] 權限控管（school_admin, org_admin）？
- [ ] 數據看板（總部看所有分校）？
- [ ] 協同教學（多位老師共同管理班級）？

**原則**：
- 不做猜測，只做客戶要的
- 快速迭代，2 週一個功能
- 持續驗證價值

**時程**：按功能而定（2-4 週/功能）

---

### ⏭️ Step 3: 規模化（在找到 PMF 後）

- [ ] 完善產品功能
- [ ] 建立標準化銷售流程
- [ ] 擴大客戶數量（5-10 家）

---

## 💡 策略轉變

**舊思維**：先想清楚所有問題 → 設計完美架構 → 開發 → 銷售
**新思維**：建立彈性架構 → 找客戶 → 邊做邊調整 → PMF

**為什麼**：
- 商業策略無法空想（需要市場驗證）
- 過度設計浪費時間（客戶可能不要）
- 彈性架構 = 最小成本 + 最大選項

---

## 📚 相關文件

- **產品需求**：[PRD.md](./PRD.md)
- **部署與 CI/CD**：[CICD.md](./CICD.md)

---

**文件狀態**: 🔴 等待商業策略決定（Step 0）
**建立日期**: 2025-11-26
**最後更新**: 2025-11-26
**負責人**: [待指派]

---

## 💡 核心原則

**順序很重要**：
1. **為什麼做**（商業價值）→ 先想 ✅ 已確認
2. **賣給誰**（目標市場）→ 再想 ⏸️ 延後決定
3. **做什麼**（產品功能）→ 接著想 ⏸️ 邊做邊學
4. **怎麼做**（技術實作）→ 最後想 ✅ 已設計

**策略調整**：
- ✅ 建立「萬用架構」→ 可適應各種商業策略
- ✅ 商業決策延後 → 等第一個客戶確認
- ✅ 技術可回滾 → 錯了隨時改

## 🎯 核心決策（最終確定版 - 零破壞性方案）

### ✅ 關鍵洞察 1：Teacher = User

**發現**：
- Teachers 表本來就有 email, password_hash, name
- Teachers 表本來就是 User 表！
- 只是名字叫 teachers，讓我們以為只能是「教課的人」

**解法**：
- ❌ 不改表名（其他人還在開發）
- ✅ 機構內所有人都是 "teacher"（只是 role 不同）
- ✅ 學生保持單純（只在班級內）

---

### ✅ 關鍵洞察 2：用關聯表取代加欄位

**問題發現過程**：

**問題 1**：機構內不只有老師
```
❌ 錯誤想法：只有教課的人
✅ 正確理解：
  - 機構所有人（老闆）
  - 學校管理者（校長、主任）
  - 教學人員（老師）
  - 行政人員（助理）
  → 全部都用 teachers 表
```

**問題 2**：為什麼不直接加欄位到 teachers 表？
```
❌ 方案 A：加欄位
ALTER TABLE teachers ADD COLUMN organization_id UUID;
ALTER TABLE teachers ADD COLUMN school_id UUID;
ALTER TABLE teachers ADD COLUMN roles JSONB;

缺點：
- 破壞現有結構
- 其他開發者受影響
- 回滾困難
- 限制擴展性（school_id 只能一個）
```

**問題 3**：老師能跨校嗎？
```
情境：李老師在台北、新竹兩校區教課
如果 teacher.school_id = 台北
→ ❌ 新竹怎麼辦？

情境：王老師從台北調到新竹
改 teacher.school_id = 新竹
→ ❌ 台北的歷史記錄遺失
```

**問題 4**：需要幾個 roles？
```
❌ 錯誤設計：
teachers.roles = ["org_owner"]          ← 機構角色
teacher_schools.roles = ["school_admin"] ← 學校角色

問題：兩個地方都要查，邏輯混亂
```

---

### ✅ 最終方案：完全用關聯表

**核心思想**：
```
與其修改現有表（破壞性）
不如全部用關聯表（非破壞性）
```

**優點**：
1. ✅ **零破壞性**：完全不動 teachers, classrooms, students 表
2. ✅ **完美回滾**：DROP 新表就好，5 秒恢復
3. ✅ **零影響**：其他開發者完全無感
4. ✅ **彈性無限**：未來 1:1 → 1:N → N:M 隨時切換
5. ✅ **邏輯清晰**：所有新邏輯都在新表，不污染舊表

**取捨**：
- ⚠️ 查詢多一次 JOIN（但可用 ORM relationship 優化）
- ⚠️ 表的數量增加（但邏輯更清楚）
- ✅ 換來：零風險、易回滾、易擴展

---

## 📝 最小必要改動清單（零破壞性版本）

### **Phase 1: 資料庫改動（完全用關聯表）**

```sql
-- ============================================
-- 1. 核心表（完全獨立，不關聯現有表）
-- ============================================

CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  type VARCHAR(50) DEFAULT 'organization',  -- 'personal' | 'organization'
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE schools (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- ============================================
-- 2. 關聯表（連接新舊世界，不破壞舊表）
-- ============================================

-- 老師 - 機構關聯（支援未來跨組織）
CREATE TABLE teacher_organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  teacher_id INTEGER NOT NULL REFERENCES teachers(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  joined_at TIMESTAMP DEFAULT NOW(),
  left_at TIMESTAMP NULL,
  is_active BOOLEAN DEFAULT TRUE,

  UNIQUE(teacher_id, organization_id)
);

-- 老師 - 學校關聯（支援跨校、調校、角色管理）
CREATE TABLE teacher_schools (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  teacher_id INTEGER NOT NULL REFERENCES teachers(id) ON DELETE CASCADE,
  school_id UUID REFERENCES schools(id) ON DELETE CASCADE NULL,
  -- ↑ NULL = 機構層級角色（如 CEO）

  roles JSONB NOT NULL DEFAULT '["teacher"]',
  -- ↑ 所有角色都在這：["org_owner"], ["school_admin"], ["teacher"]

  joined_at TIMESTAMP DEFAULT NOW(),
  left_at TIMESTAMP NULL,
  is_active BOOLEAN DEFAULT TRUE,

  UNIQUE(teacher_id, school_id)
);

-- 班級 - 學校關聯（未來可改為多對多，如線上課程）
CREATE TABLE classroom_schools (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  classroom_id INTEGER NOT NULL REFERENCES classrooms(id) ON DELETE CASCADE,
  school_id UUID NOT NULL REFERENCES schools(id) ON DELETE CASCADE,
  joined_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,

  UNIQUE(classroom_id)  -- 目前一個班級只屬於一個學校
);

-- ============================================
-- 3. 索引（效能優化）
-- ============================================

CREATE INDEX idx_teacher_org_teacher ON teacher_organizations(teacher_id);
CREATE INDEX idx_teacher_org_org ON teacher_organizations(organization_id);
CREATE INDEX idx_teacher_org_active ON teacher_organizations(teacher_id, is_active);

CREATE INDEX idx_teacher_school_teacher ON teacher_schools(teacher_id);
CREATE INDEX idx_teacher_school_school ON teacher_schools(school_id);
CREATE INDEX idx_teacher_school_active ON teacher_schools(teacher_id, is_active);
CREATE INDEX idx_teacher_school_roles ON teacher_schools USING GIN(roles);

CREATE INDEX idx_classroom_school_classroom ON classroom_schools(classroom_id);
CREATE INDEX idx_classroom_school_school ON classroom_schools(school_id);
```

---

### **改動統計（最終版）**

| 項目 | 數量 | 說明 |
|------|-----|------|
| **修改現有表** | **0 個** ✅ | teachers, classrooms, students 完全不動 |
| **新增欄位到現有表** | **0 個** ✅ | 完全不破壞現有結構 |
| **新增獨立表** | 2 個 | organizations, schools |
| **新增關聯表** | 3 個 | teacher_organizations, teacher_schools, classroom_schools |
| **新增索引** | 9 個 | 效能優化 |

**結論**：
- ✅ 現有表：0% 修改
- ✅ 現有 code：0% 需改
- ✅ 其他開發者：0% 影響
- ✅ 回滾時間：5 秒

---

### **Phase 2: 資料遷移（自動執行）**

```python
# 遷移腳本（執行一次）
def migrate_existing_teachers():
    for teacher in Teacher.query.all():
        # 1. 建立個人機構
        org = Organization.create(
            name=f"{teacher.name}的工作室",
            type="personal"
        )

        # 2. 建立個人學校
        school = School.create(
            organization_id=org.id,
            name=f"{teacher.name}的工作室"
        )

        # 3. 更新 teacher
        teacher.organization_id = org.id
        teacher.school_id = school.id
        teacher.roles = ["teacher"]  # 預設角色

        # 4. 更新 teacher 的所有班級
        for classroom in teacher.classrooms:
            classroom.school_id = school.id

    db.session.commit()
```

**影響**：
- 現有用戶：✅ 完全無感（自動變成個人機構）
- 現有功能：✅ 完全不變
- API：✅ 不需修改（舊查詢仍可用）

---

### **Phase 3: API 調整（向下相容）**

**原則**：舊 API 保持不變，只加新 API

```python
# ✅ 舊 API 保持不變
@app.get("/api/teachers/{teacher_id}/classrooms")
def get_teacher_classrooms(teacher_id: int):
    teacher = Teacher.get(teacher_id)
    return teacher.classrooms  # ← 完全不變

# ✅ 新 API（新功能）
@app.get("/api/organizations/{org_id}/classrooms")
def get_org_classrooms(org_id: str, current_user: Teacher):
    # 權限檢查
    if "org_owner" not in current_user.roles:
        raise PermissionError

    # 查詢該機構所有班級
    schools = School.query.filter_by(organization_id=org_id).all()
    school_ids = [s.id for s in schools]
    classrooms = Classroom.query.filter(
        Classroom.school_id.in_(school_ids)
    ).all()

    return classrooms
```

**改動統計**：
- 修改現有 API：0 個 ✅
- 新增 API：約 5-10 個（機構管理用）

---

### **Phase 4: 前端調整（Feature Flag）**

```typescript
// 根據 roles 顯示不同功能
function TeacherLayout({ teacher }) {
  const hasOrgOwner = teacher.roles.includes('org_owner');
  const hasSchoolAdmin = teacher.roles.includes('school_admin');
  const hasTeacher = teacher.roles.includes('teacher');

  return (
    <Layout>
      {/* 舊功能：所有人都看得到 */}
      {hasTeacher && <TeacherDashboard />}

      {/* 新功能：只有特定角色看得到 */}
      {hasOrgOwner && <OrganizationDashboard />}
      {hasSchoolAdmin && <SchoolDashboard />}
    </Layout>
  );
}
```

**改動統計**：
- 修改現有組件：0 個 ✅
- 新增組件：約 3-5 個（機構管理介面）

---

## 📊 改動影響評估

| 項目 | 改動數量 | 影響範圍 | 風險 |
|------|---------|---------|------|
| **資料庫 Schema** | 新增 2 表 + 4 欄位 | 0% 現有功能 | 🟢 極低 |
| **資料遷移** | 1 個腳本 | 自動執行 | 🟢 極低 |
| **後端 API** | 0 個修改 + 5-10 個新增 | 0% 現有 API | 🟢 極低 |
| **前端 UI** | 0 個修改 + 3-5 個新增 | 0% 現有頁面 | 🟢 極低 |
| **測試** | 新增測試 | 新功能測試 | 🟢 極低 |

**結論**：
- ✅ 現有開發人員：完全不受影響
- ✅ 現有功能：100% 保持不變
- ✅ 新功能：獨立開發，不干擾

---

## 🛡️ 回滾保證

```sql
-- 如果需要回滾（5 秒內完成）
BEGIN;

-- 1. 移除欄位
ALTER TABLE teachers DROP COLUMN organization_id;
ALTER TABLE teachers DROP COLUMN school_id;
ALTER TABLE teachers DROP COLUMN roles;
ALTER TABLE classrooms DROP COLUMN school_id;

-- 2. 刪除表
DROP TABLE schools CASCADE;
DROP TABLE organizations CASCADE;

COMMIT;

-- 結果：系統回到改動前，所有現有功能正常運作
```

---

## 🎯 核心決策（已確定）

### ✅ 1. 架構模式：「軟性機構」
- 所有老師都自動屬於一個 organization
- 獨立老師 = 1 人機構（type: personal）
- 資料結構統一，UI 根據 type 動態顯示

### ✅ 2. 帳號模式：「多帳號」
- 老師 = 組織的資源（就像員工 = 公司的資源）
- 換組織 = 新帳號（就像換公司會有新 email）
- 資料完全隔離，帳務清楚

### ✅ 3. 回滾保證：「100% 可逆」
- 舊欄位全部保留（teacher_id 不刪除）
- 新欄位都是 nullable（可隨時刪除）
- Feature Flag 控制（可隨時關閉）
- 5 秒內完整回滾

### ✅ 4. 擴展策略：「按需開發」
- Phase 1: 萬用架構（立即做）
- Phase 2: 找客戶驗證（邊做邊學）
- Phase 3: 快速迭代（只做客戶要的）

**記住**：
- ✅ 架構彈性 > 功能完整（先求能動，再求好用）
- ✅ 可回滾性 > 完美設計（錯了可以改）
- ✅ 市場驅動 > 工程師直覺（讓客戶告訴我們要什麼）

---

## 📘 使用範例與查詢模式

### 1. 基礎查詢（向下相容）

```python
# ✅ 舊查詢方式（完全不變）
teacher = Teacher.query.get(123)
classrooms = Classroom.query.filter_by(teacher_id=teacher.id).all()
# → 完全正常運作，不需修改

# ✅ 新查詢方式（使用關聯）
teacher_org = TeacherOrganization.query.filter_by(
    teacher_id=teacher.id,
    is_active=True
).first()
organization = teacher_org.organization
```

---

### 2. 角色系統範例

```python
# teacher_schools.roles 是 JSONB array

# 範例 1：單一角色
{
  "teacher_id": 123,
  "school_id": "uuid-abc",
  "roles": ["teacher"]  # 只是老師
}

# 範例 2：多重角色（校長也教課）
{
  "teacher_id": 456,
  "school_id": "uuid-abc",
  "roles": ["school_admin", "teacher"]  # 既是管理者也教課
}

# 範例 3：機構層級角色（CEO 不屬於特定學校）
{
  "teacher_id": 789,
  "school_id": null,  # ← NULL = 機構層級
  "roles": ["org_owner"]  # 機構所有人
}

# 範例 4：集團 CEO 兼任台北校長
INSERT INTO teacher_schools VALUES
  (uuid1, 789, null, '["org_owner"]'),           # 機構層級
  (uuid2, 789, 'uuid-taipei', '["school_admin"]'); # 台北校長
```

---

### 3. 權限檢查範例

```python
def has_permission(teacher_id: int, permission: str, school_id: str = None):
    """
    檢查老師權限

    Args:
        teacher_id: 老師 ID
        permission: 權限類型 ("org_owner", "school_admin", "teacher")
        school_id: 學校 ID（如果是 None，檢查機構層級權限）
    """
    query = TeacherSchool.query.filter(
        TeacherSchool.teacher_id == teacher_id,
        TeacherSchool.is_active == True
    )

    if school_id:
        query = query.filter(TeacherSchool.school_id == school_id)
    else:
        query = query.filter(TeacherSchool.school_id == None)

    teacher_school = query.first()
    if not teacher_school:
        return False

    # JSONB array contains check
    return permission in teacher_school.roles

# 使用範例
if has_permission(teacher.id, "org_owner"):
    # 可以管理整個機構
    pass

if has_permission(teacher.id, "school_admin", school_id="uuid-abc"):
    # 可以管理特定學校
    pass
```

---

### 4. 查詢機構所有班級

```python
def get_organization_classrooms(org_id: str):
    """
    查詢機構所有班級（跨所有學校）
    """
    return db.session.query(Classroom).join(
        ClassroomSchool, Classroom.id == ClassroomSchool.classroom_id
    ).join(
        School, ClassroomSchool.school_id == School.id
    ).filter(
        School.organization_id == org_id,
        ClassroomSchool.is_active == True
    ).all()

# ORM relationship 方式（推薦）
class School(Base):
    classrooms = relationship(
        "Classroom",
        secondary="classroom_schools",
        backref="schools"
    )

# 使用
school = School.query.get(school_id)
classrooms = school.classrooms  # ← 簡單優雅
```

---

### 5. 老師跨校查詢

```python
def get_teacher_schools(teacher_id: int):
    """
    查詢老師任教的所有學校
    """
    return db.session.query(School).join(
        TeacherSchool, School.id == TeacherSchool.school_id
    ).filter(
        TeacherSchool.teacher_id == teacher_id,
        TeacherSchool.is_active == True
    ).all()

# 使用範例
teacher = Teacher.query.get(123)
schools = get_teacher_schools(teacher.id)
# → [台北校區, 新竹校區]

# 查詢老師在特定學校的角色
teacher_school = TeacherSchool.query.filter_by(
    teacher_id=teacher.id,
    school_id=school_id,
    is_active=True
).first()
roles = teacher_school.roles
# → ["teacher"] 或 ["school_admin", "teacher"]
```

---

### 6. 歷史記錄查詢

```python
def get_teacher_school_history(teacher_id: int):
    """
    查詢老師的調校歷史
    """
    return TeacherSchool.query.filter(
        TeacherSchool.teacher_id == teacher_id
    ).order_by(TeacherSchool.joined_at.desc()).all()

# 使用範例
history = get_teacher_school_history(123)
for record in history:
    if record.is_active:
        print(f"目前任職：{record.school.name}")
    else:
        print(f"曾任職：{record.school.name} "
              f"({record.joined_at} - {record.left_at})")
```

---

### 7. SQLAlchemy ORM Models（推薦）

```python
# models.py 新增

class Organization(Base):
    __tablename__ = 'organizations'

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    type = Column(String(50), default='organization')
    settings = Column(JSONB, default={})
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    schools = relationship("School", back_populates="organization")
    teacher_organizations = relationship("TeacherOrganization", back_populates="organization")

class School(Base):
    __tablename__ = 'schools'

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    organization_id = Column(UUID, ForeignKey('organizations.id'), nullable=False)
    name = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    organization = relationship("Organization", back_populates="schools")
    teacher_schools = relationship("TeacherSchool", back_populates="school")
    classroom_schools = relationship("ClassroomSchool", back_populates="school")

class TeacherOrganization(Base):
    __tablename__ = 'teacher_organizations'

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    teacher_id = Column(Integer, ForeignKey('teachers.id', ondelete='CASCADE'), nullable=False)
    organization_id = Column(UUID, ForeignKey('organizations.id', ondelete='CASCADE'), nullable=False)
    joined_at = Column(DateTime, default=datetime.utcnow)
    left_at = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True)

    __table_args__ = (
        UniqueConstraint('teacher_id', 'organization_id'),
    )

    # Relationships
    teacher = relationship("Teacher", back_populates="teacher_organizations")
    organization = relationship("Organization", back_populates="teacher_organizations")

class TeacherSchool(Base):
    __tablename__ = 'teacher_schools'

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    teacher_id = Column(Integer, ForeignKey('teachers.id', ondelete='CASCADE'), nullable=False)
    school_id = Column(UUID, ForeignKey('schools.id', ondelete='CASCADE'), nullable=True)  # NULL = org-level
    roles = Column(JSONB, nullable=False, default=["teacher"])
    joined_at = Column(DateTime, default=datetime.utcnow)
    left_at = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True)

    __table_args__ = (
        UniqueConstraint('teacher_id', 'school_id'),
    )

    # Relationships
    teacher = relationship("Teacher", back_populates="teacher_schools")
    school = relationship("School", back_populates="teacher_schools")

class ClassroomSchool(Base):
    __tablename__ = 'classroom_schools'

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    classroom_id = Column(Integer, ForeignKey('classrooms.id', ondelete='CASCADE'), nullable=False)
    school_id = Column(UUID, ForeignKey('schools.id', ondelete='CASCADE'), nullable=False)
    joined_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)

    __table_args__ = (
        UniqueConstraint('classroom_id'),  # 目前一班一校
    )

    # Relationships
    classroom = relationship("Classroom", back_populates="classroom_schools")
    school = relationship("School", back_populates="classroom_schools")

# 更新現有 models

class Teacher(Base):
    # ... 原有欄位保持不變 ...

    # 新增 relationships（不修改表結構）
    teacher_organizations = relationship("TeacherOrganization", back_populates="teacher")
    teacher_schools = relationship("TeacherSchool", back_populates="teacher")

    # 便利屬性
    @property
    def current_organization(self):
        """取得目前所屬機構"""
        active = [to for to in self.teacher_organizations if to.is_active]
        return active[0].organization if active else None

    @property
    def current_schools(self):
        """取得目前任教的所有學校"""
        return [ts.school for ts in self.teacher_schools if ts.is_active and ts.school_id]

    @property
    def roles(self):
        """取得所有角色（合併所有學校）"""
        all_roles = set()
        for ts in self.teacher_schools:
            if ts.is_active:
                all_roles.update(ts.roles)
        return list(all_roles)

class Classroom(Base):
    # ... 原有欄位保持不變 ...

    # 新增 relationships
    classroom_schools = relationship("ClassroomSchool", back_populates="classroom")

    @property
    def current_school(self):
        """取得目前所屬學校"""
        active = [cs for cs in self.classroom_schools if cs.is_active]
        return active[0].school if active else None
```

---

### 8. 資料遷移腳本（完整版）

```python
# migrations/versions/xxx_add_organization_hierarchy.py

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID, JSONB
import uuid

def upgrade():
    # 1. 建立核心表
    op.create_table(
        'organizations',
        sa.Column('id', UUID, primary_key=True, default=uuid.uuid4),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('type', sa.String(50), default='organization'),
        sa.Column('settings', JSONB, default={}),
        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())
    )

    op.create_table(
        'schools',
        sa.Column('id', UUID, primary_key=True, default=uuid.uuid4),
        sa.Column('organization_id', UUID, sa.ForeignKey('organizations.id'), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())
    )

    # 2. 建立關聯表
    op.create_table(
        'teacher_organizations',
        sa.Column('id', UUID, primary_key=True, default=uuid.uuid4),
        sa.Column('teacher_id', sa.Integer, sa.ForeignKey('teachers.id', ondelete='CASCADE'), nullable=False),
        sa.Column('organization_id', UUID, sa.ForeignKey('organizations.id', ondelete='CASCADE'), nullable=False),
        sa.Column('joined_at', sa.DateTime, server_default=sa.func.now()),
        sa.Column('left_at', sa.DateTime, nullable=True),
        sa.Column('is_active', sa.Boolean, default=True),
        sa.UniqueConstraint('teacher_id', 'organization_id')
    )

    op.create_table(
        'teacher_schools',
        sa.Column('id', UUID, primary_key=True, default=uuid.uuid4),
        sa.Column('teacher_id', sa.Integer, sa.ForeignKey('teachers.id', ondelete='CASCADE'), nullable=False),
        sa.Column('school_id', UUID, sa.ForeignKey('schools.id', ondelete='CASCADE'), nullable=True),
        sa.Column('roles', JSONB, nullable=False, server_default='["teacher"]'),
        sa.Column('joined_at', sa.DateTime, server_default=sa.func.now()),
        sa.Column('left_at', sa.DateTime, nullable=True),
        sa.Column('is_active', sa.Boolean, default=True),
        sa.UniqueConstraint('teacher_id', 'school_id')
    )

    op.create_table(
        'classroom_schools',
        sa.Column('id', UUID, primary_key=True, default=uuid.uuid4),
        sa.Column('classroom_id', sa.Integer, sa.ForeignKey('classrooms.id', ondelete='CASCADE'), nullable=False),
        sa.Column('school_id', UUID, sa.ForeignKey('schools.id', ondelete='CASCADE'), nullable=False),
        sa.Column('joined_at', sa.DateTime, server_default=sa.func.now()),
        sa.Column('is_active', sa.Boolean, default=True),
        sa.UniqueConstraint('classroom_id')
    )

    # 3. 建立索引
    op.create_index('idx_teacher_org_teacher', 'teacher_organizations', ['teacher_id'])
    op.create_index('idx_teacher_org_org', 'teacher_organizations', ['organization_id'])
    op.create_index('idx_teacher_org_active', 'teacher_organizations', ['teacher_id', 'is_active'])

    op.create_index('idx_teacher_school_teacher', 'teacher_schools', ['teacher_id'])
    op.create_index('idx_teacher_school_school', 'teacher_schools', ['school_id'])
    op.create_index('idx_teacher_school_active', 'teacher_schools', ['teacher_id', 'is_active'])
    op.create_index('idx_teacher_school_roles', 'teacher_schools', ['roles'], postgresql_using='gin')

    op.create_index('idx_classroom_school_classroom', 'classroom_schools', ['classroom_id'])
    op.create_index('idx_classroom_school_school', 'classroom_schools', ['school_id'])

    # 4. 資料遷移（PostgreSQL）
    op.execute("""
        -- 為每個現有老師建立個人機構和學校
        WITH new_orgs AS (
            INSERT INTO organizations (id, name, type, settings, created_at, updated_at)
            SELECT
                gen_random_uuid(),
                name || '的工作室',
                'personal',
                '{}'::jsonb,
                NOW(),
                NOW()
            FROM teachers
            RETURNING id, name
        ),
        new_schools AS (
            INSERT INTO schools (id, organization_id, name, created_at, updated_at)
            SELECT
                gen_random_uuid(),
                no.id,
                no.name,
                NOW(),
                NOW()
            FROM new_orgs no
            RETURNING id, organization_id
        ),
        teacher_org_links AS (
            INSERT INTO teacher_organizations (id, teacher_id, organization_id, joined_at, is_active)
            SELECT
                gen_random_uuid(),
                t.id,
                no.id,
                NOW(),
                true
            FROM teachers t
            JOIN new_orgs no ON no.name = t.name || '的工作室'
            RETURNING teacher_id, organization_id
        ),
        teacher_school_links AS (
            INSERT INTO teacher_schools (id, teacher_id, school_id, roles, joined_at, is_active)
            SELECT
                gen_random_uuid(),
                tol.teacher_id,
                ns.id,
                '["teacher"]'::jsonb,
                NOW(),
                true
            FROM teacher_org_links tol
            JOIN new_schools ns ON ns.organization_id = tol.organization_id
            RETURNING teacher_id, school_id
        )
        INSERT INTO classroom_schools (id, classroom_id, school_id, joined_at, is_active)
        SELECT
            gen_random_uuid(),
            c.id,
            tsl.school_id,
            NOW(),
            true
        FROM classrooms c
        JOIN teacher_school_links tsl ON tsl.teacher_id = c.teacher_id;
    """)

def downgrade():
    """完全回滾所有改動"""
    # 刪除索引
    op.drop_index('idx_classroom_school_school')
    op.drop_index('idx_classroom_school_classroom')
    op.drop_index('idx_teacher_school_roles')
    op.drop_index('idx_teacher_school_active')
    op.drop_index('idx_teacher_school_school')
    op.drop_index('idx_teacher_school_teacher')
    op.drop_index('idx_teacher_org_active')
    op.drop_index('idx_teacher_org_org')
    op.drop_index('idx_teacher_org_teacher')

    # 刪除關聯表（CASCADE 會自動處理 FK）
    op.drop_table('classroom_schools')
    op.drop_table('teacher_schools')
    op.drop_table('teacher_organizations')

    # 刪除核心表
    op.drop_table('schools')
    op.drop_table('organizations')
```

---

### 9. API 端點範例

```python
# api/routes/organizations.py

from flask import Blueprint, jsonify, request
from models import Organization, School, Teacher, TeacherSchool
from auth import require_auth, require_role

org_bp = Blueprint('organizations', __name__)

@org_bp.get('/api/organizations/<org_id>')
@require_auth
@require_role('org_owner', 'school_admin')
def get_organization(org_id):
    """取得機構資訊"""
    org = Organization.query.get_or_404(org_id)
    return jsonify({
        'id': org.id,
        'name': org.name,
        'type': org.type,
        'schools': [
            {'id': s.id, 'name': s.name}
            for s in org.schools
        ]
    })

@org_bp.get('/api/organizations/<org_id>/teachers')
@require_auth
@require_role('org_owner', 'school_admin')
def get_organization_teachers(org_id):
    """取得機構所有老師"""
    teachers = db.session.query(Teacher).join(
        TeacherOrganization
    ).filter(
        TeacherOrganization.organization_id == org_id,
        TeacherOrganization.is_active == True
    ).all()

    return jsonify([
        {
            'id': t.id,
            'name': t.name,
            'email': t.email,
            'roles': t.roles,
            'schools': [s.name for s in t.current_schools]
        }
        for t in teachers
    ])

@org_bp.post('/api/organizations/<org_id>/teachers')
@require_auth
@require_role('org_owner')
def invite_teacher(org_id):
    """邀請新老師加入機構"""
    data = request.json

    # 建立 teacher
    teacher = Teacher.create(
        name=data['name'],
        email=data['email'],
        password_hash=generate_password_hash(data['password'])
    )

    # 建立機構關聯
    TeacherOrganization.create(
        teacher_id=teacher.id,
        organization_id=org_id,
        is_active=True
    )

    # 建立學校關聯（如果指定）
    if 'school_id' in data:
        TeacherSchool.create(
            teacher_id=teacher.id,
            school_id=data['school_id'],
            roles=data.get('roles', ['teacher']),
            is_active=True
        )

    return jsonify({'id': teacher.id, 'message': '邀請成功'}), 201

@org_bp.put('/api/organizations/<org_id>/teachers/<int:teacher_id>/roles')
@require_auth
@require_role('org_owner')
def update_teacher_roles(org_id, teacher_id):
    """更新老師角色"""
    data = request.json
    school_id = data.get('school_id')
    new_roles = data['roles']

    teacher_school = TeacherSchool.query.filter_by(
        teacher_id=teacher_id,
        school_id=school_id,
        is_active=True
    ).first_or_404()

    teacher_school.roles = new_roles
    db.session.commit()

    return jsonify({'message': '角色更新成功'})
```

---

## 🎯 角色權限矩陣

| 功能 | org_owner | school_admin | teacher |
|------|-----------|--------------|---------|
| **機構層級** | | | |
| 查看機構資訊 | ✅ | ✅（只看自己學校） | ❌ |
| 修改機構設定 | ✅ | ❌ | ❌ |
| 新增/刪除學校 | ✅ | ❌ | ❌ |
| 邀請老師（機構） | ✅ | ❌ | ❌ |
| **學校層級** | | | |
| 查看學校資訊 | ✅ | ✅ | ✅（只看自己的） |
| 修改學校設定 | ✅ | ✅ | ❌ |
| 邀請老師（學校） | ✅ | ✅ | ❌ |
| 管理老師角色 | ✅ | ✅ | ❌ |
| 查看所有班級 | ✅ | ✅ | ❌ |
| **班級層級** | | | |
| 建立班級 | ✅ | ✅ | ✅ |
| 管理自己的班級 | ✅ | ✅ | ✅ |
| 管理他人班級 | ✅ | ✅ | ❌ |
| 查看班級數據 | ✅ | ✅ | ✅（只看自己的） |

---

## 📊 完整架構圖

```
┌─────────────────────────────────────────────────────────┐
│                    Organizations                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ 個人工作室    │  │ 小型補習班    │  │ 連鎖補習班    │  │
│  │ type:personal│  │ type:org     │  │ type:org     │  │
│  │ 1 teacher    │  │ 5 teachers   │  │ 50 teachers  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
           │                  │                  │
           ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────┐
│                       Schools                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ 王老師工作室  │  │ 主校區        │  │ 台北、新竹    │  │
│  │ (自動建立)    │  │              │  │ 台中、高雄    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
           │                  │                  │
           ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────┐
│                    Teacher-Schools                       │
│  ┌──────────────────────────────────────────────────┐   │
│  │ teacher_id | school_id | roles           | active│   │
│  ├──────────────────────────────────────────────────┤   │
│  │ 123        | uuid-abc  | ["teacher"]     | true  │   │
│  │ 456        | uuid-abc  | ["school_admin"]| true  │   │
│  │ 789        | NULL      | ["org_owner"]   | true  │   │
│  │ 789        | uuid-tpe  | ["school_admin"]| true  │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                     Classrooms                           │
│  透過 classroom_schools 連接到 schools                   │
│  teacher_id 欄位保留（向下相容）                          │
└─────────────────────────────────────────────────────────┘
```

---

## ✅ 最終檢查清單

在執行 migration 前，確認：

- [ ] 備份資料庫（`pg_dump`）
- [ ] 測試環境先測試 migration
- [ ] 驗證 downgrade 可以成功回滾
- [ ] 現有 API 測試全部通過
- [ ] 新 ORM models 測試通過
- [ ] 查詢效能測試（JOIN 是否影響效能）
- [ ] 索引是否正確建立
- [ ] 資料遷移完整性檢查（所有 teacher 都有 organization）
- [ ] Feature flag 設定正確
- [ ] 監控系統準備好（追蹤 migration 影響）

---

## 🚀 部署流程

### Step 1: Staging 環境測試
```bash
# 1. 執行 migration
alembic upgrade head

# 2. 驗證資料
psql -c "SELECT COUNT(*) FROM organizations;"
psql -c "SELECT COUNT(*) FROM teacher_organizations;"

# 3. 測試查詢效能
python scripts/test_query_performance.py

# 4. 測試回滾
alembic downgrade -1
alembic upgrade head
```

### Step 2: Production 部署
```bash
# 1. 公告維護（預計 5 分鐘）
# 2. 資料庫備份
pg_dump duotopia > backup_before_org_migration.sql

# 3. 執行 migration
alembic upgrade head

# 4. 快速驗證
# 5. 監控 error logs 30 分鐘
# 6. 如有問題立即回滾
```

### Step 3: 監控指標
```
- API response time（預期：< 5% 增加）
- Database connection pool（預期：無變化）
- Error rate（預期：0 新錯誤）
- Migration 執行時間（預期：< 5 分鐘）
```
