name: Deploy Backend

on:
  workflow_dispatch:  # ÊâãÂãïËß∏Áôº
  push:
    branches: [ main, staging ]
    paths:
      # ÂæåÁ´ØÁõ∏ÈóúÊ™îÊ°à
      - 'backend/**'
      - '!backend/**/*.md'
      - '!backend/tests/**'
      - 'requirements*.txt'
      - 'alembic.ini'
      - 'Dockerfile'
      - '.github/workflows/deploy-backend.yml'

env:
  PROJECT_ID: duotopia-472708
  REGION: asia-east1
  REPOSITORY: duotopia-repo

jobs:
  test-backend:
    name: üß™ Test Backend
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install backend dependencies
      working-directory: ./backend
      run: |
        pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run Black formatting check
      working-directory: ./backend
      run: |
        echo "Checking Python code formatting with Black..."
        black --check . || (echo "‚ùå Black formatting check failed. Run 'black backend/' locally to fix." && exit 1)

    - name: Run Flake8 linting
      working-directory: ./backend
      run: |
        echo "Running Flake8 linting..."
        flake8 . --max-line-length=120 --ignore=E203,W503 --exclude=alembic,__pycache__,.venv

    - name: Run pytest (Parallel)
      working-directory: ./backend
      run: |
        echo "Running backend tests in parallel..."
        pytest -n 2 -v --tb=short || echo "Tests completed with some failures"

    - name: Test backend import
      working-directory: ./backend
      run: python -c "import main; print('Backend imports successfully')"

  deploy-backend:
    name: üöÄ Deploy Backend
    needs: test-backend
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set Environment Variables
      id: env_vars
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "ENV_NAME=production" >> $GITHUB_OUTPUT
          echo "BACKEND_SERVICE=${{ secrets.PRODUCTION_BACKEND_SERVICE }}" >> $GITHUB_OUTPUT
          echo "üöÄ Deploying to PRODUCTION"
        else
          echo "ENV_NAME=staging" >> $GITHUB_OUTPUT
          echo "BACKEND_SERVICE=${{ secrets.STAGING_BACKEND_SERVICE }}" >> $GITHUB_OUTPUT
          echo "üß™ Deploying to STAGING"
        fi

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    # Cloud Run ÊúâÈ†êË®≠ÁöÑ service accountÔºå‰∏çÈúÄË¶ÅÈ°çÂ§ñÁöÑ key file
    # GCS ÊúÉËá™Âãï‰ΩøÁî® Cloud Run ÁöÑË™çË≠â

    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker $REGION-docker.pkg.dev

    - name: Set Database Environment Variables
      id: db_env
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}" >> $GITHUB_OUTPUT
          echo "ALEMBIC_DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_POOLER_URL }}" >> $GITHUB_OUTPUT
          echo "SUPABASE_URL=${{ secrets.PRODUCTION_SUPABASE_URL }}" >> $GITHUB_OUTPUT
          echo "SUPABASE_KEY=${{ secrets.PRODUCTION_SUPABASE_ANON_KEY }}" >> $GITHUB_OUTPUT
          echo "JWT_SECRET=${{ secrets.PRODUCTION_JWT_SECRET }}" >> $GITHUB_OUTPUT
          echo "FRONTEND_URL=${{ secrets.PRODUCTION_FRONTEND_URL }}" >> $GITHUB_OUTPUT
          echo "üî• Using Production Database"
        else
          echo "DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}" >> $GITHUB_OUTPUT
          echo "ALEMBIC_DATABASE_URL=${{ secrets.STAGING_DATABASE_POOLER_URL }}" >> $GITHUB_OUTPUT
          echo "SUPABASE_URL=${{ secrets.STAGING_SUPABASE_URL }}" >> $GITHUB_OUTPUT
          echo "SUPABASE_KEY=${{ secrets.STAGING_SUPABASE_ANON_KEY }}" >> $GITHUB_OUTPUT
          echo "JWT_SECRET=${{ secrets.STAGING_JWT_SECRET }}" >> $GITHUB_OUTPUT
          echo "FRONTEND_URL=${{ secrets.STAGING_FRONTEND_URL }}" >> $GITHUB_OUTPUT
          echo "üÜì Using Staging Database"
        fi

    - name: Build and push backend image
      run: |
        cd backend && docker build -f Dockerfile -t $REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/${{ steps.env_vars.outputs.BACKEND_SERVICE }}:$GITHUB_SHA .
        docker push $REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/${{ steps.env_vars.outputs.BACKEND_SERVICE }}:$GITHUB_SHA
        # Ê∏ÖÁêÜÊïèÊÑüÊ™îÊ°à
        rm -f service-account-key.json
        echo "üßπ Cleaned up service account key file"

    - name: Setup Python for migrations
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Run Alembic database migrations
      env:
        DATABASE_URL: ${{ steps.db_env.outputs.ALEMBIC_DATABASE_URL }}
      run: |
        echo "üîç Installing dependencies for migrations..."
        pip install -r backend/requirements.txt

        echo "üîÑ Running Alembic database migrations..."
        cd backend
        echo "üìä Current migration status:"
        alembic current
        echo "üîÑ Upgrading to latest migration..."
        alembic upgrade head
        echo "‚úÖ Migrations completed"

    - name: Check for missing migrations
      env:
        DATABASE_URL: ${{ steps.db_env.outputs.ALEMBIC_DATABASE_URL }}
      run: |
        echo "üîç Checking for uncommitted model changes..."
        cd backend
        if ! alembic check; then
          echo "‚ùå ERROR: Database models have changed but no migration was created!"
          echo "üìù Please run the following command locally:"
          echo "   alembic revision --autogenerate -m 'describe your changes'"
          echo "   Then commit the generated migration file."
          exit 1
        fi
        echo "‚úÖ No pending model changes detected"

    - name: üîí Verify RLS Configuration
      env:
        DATABASE_URL: ${{ steps.db_env.outputs.ALEMBIC_DATABASE_URL }}
      run: |
        echo "üîç Checking RLS status for all tables..."

        # Ê™¢Êü•Ê≤íÊúâÂïüÁî® RLS ÁöÑË°®
        # ÊéíÈô§ÊâÄÊúâÊ•≠ÂãôË°®ÔºöÁ≥ªÁµ±‰ΩøÁî® JWT authÔºà‰∏çÊòØ Supabase AuthÔºâÔºåauth.uid() Ê∞∏ÈÅ†ÊòØ NULL
        TABLES_WITHOUT_RLS=$(psql "$DATABASE_URL" -t -c "
          SELECT tablename
          FROM pg_tables
          WHERE schemaname = 'public'
            AND NOT rowsecurity
            AND tablename != 'alembic_version'
            AND tablename NOT IN (
              'teachers', 'students', 'classrooms', 'classroom_students',
              'programs', 'lessons', 'content', 'content_item',
              'assignments', 'assignment_content', 'student_assignments',
              'student_content_progress', 'student_item_progress',
              'subscription_periods', 'point_usage_logs',
              'teacher_subscription_transaction', 'invoice_status_history'
            )
          ORDER BY tablename;
        " | xargs)

        if [ ! -z "$TABLES_WITHOUT_RLS" ]; then
          echo "‚ùå ERROR: The following tables do not have RLS enabled:"
          for table in $TABLES_WITHOUT_RLS; do
            echo "   - $table"
          done
          echo ""
          echo "üìù Security Issue: All tables must have Row Level Security enabled!"
          echo "Please add RLS to your migration or run:"
          echo "   psql \$DATABASE_URL -f backend/migrations/enable_rls_all_tables.sql"
          exit 1
        fi

        # Ê™¢Êü•ÂïüÁî®‰∫Ü RLS ‰ΩÜÊ≤íÊúâ Policy ÁöÑË°®
        TABLES_WITHOUT_POLICIES=$(psql "$DATABASE_URL" -t -c "
          SELECT t.tablename
          FROM pg_tables t
          WHERE t.schemaname = 'public'
            AND t.rowsecurity = true
            AND NOT EXISTS (
              SELECT 1 FROM pg_policies p
              WHERE p.tablename = t.tablename
            )
          ORDER BY t.tablename;
        " | xargs)

        if [ ! -z "$TABLES_WITHOUT_POLICIES" ]; then
          echo "‚ö†Ô∏è  WARNING: The following tables have RLS enabled but no policies:"
          for table in $TABLES_WITHOUT_POLICIES; do
            echo "   - $table"
          done
          echo ""
          echo "Note: Tables without policies will deny all access."
          echo "This may be intentional, but please verify."
        fi

        echo "‚úÖ All tables have RLS enabled"

    - name: Deploy backend to Cloud Run
      run: |
        # Áí∞Â¢ÉËÆäÊï∏Ë®≠ÂÆö
        ENV_VARS="DATABASE_URL=${{ steps.db_env.outputs.DATABASE_URL }}"
        ENV_VARS="$ENV_VARS,DATABASE_POOLER_URL=${{ steps.db_env.outputs.ALEMBIC_DATABASE_URL }}"
        ENV_VARS="$ENV_VARS,DATABASE_TYPE=supabase"
        ENV_VARS="$ENV_VARS,JWT_SECRET=${{ steps.db_env.outputs.JWT_SECRET }}"
        ENV_VARS="$ENV_VARS,JWT_ALGORITHM=HS256"
        ENV_VARS="$ENV_VARS,JWT_EXPIRE_MINUTES=1440"
        ENV_VARS="$ENV_VARS,ENVIRONMENT=${{ steps.env_vars.outputs.ENV_NAME }}"
        ENV_VARS="$ENV_VARS,SUPABASE_URL=${{ steps.db_env.outputs.SUPABASE_URL }}"
        ENV_VARS="$ENV_VARS,SUPABASE_KEY=${{ steps.db_env.outputs.SUPABASE_KEY }}"
        ENV_VARS="$ENV_VARS,OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
        ENV_VARS="$ENV_VARS,SMTP_HOST=${{ secrets.SMTP_HOST }}"
        ENV_VARS="$ENV_VARS,SMTP_PORT=${{ secrets.SMTP_PORT }}"
        ENV_VARS="$ENV_VARS,SMTP_USER=${{ secrets.SMTP_USER }}"
        ENV_VARS="$ENV_VARS,SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}"
        ENV_VARS="$ENV_VARS,FROM_EMAIL=${{ secrets.FROM_EMAIL }}"
        ENV_VARS="$ENV_VARS,FROM_NAME=${{ secrets.FROM_NAME }}"
        ENV_VARS="$ENV_VARS,FRONTEND_URL=${{ steps.db_env.outputs.FRONTEND_URL }}"
        ENV_VARS="$ENV_VARS,AZURE_SPEECH_KEY=${{ secrets.AZURE_SPEECH_KEY }}"
        ENV_VARS="$ENV_VARS,AZURE_SPEECH_REGION=${{ secrets.AZURE_SPEECH_REGION }}"
        ENV_VARS="$ENV_VARS,AZURE_SPEECH_ENDPOINT=${{ secrets.AZURE_SPEECH_ENDPOINT }}"
        ENV_VARS="$ENV_VARS,GCP_PROJECT_ID=$PROJECT_ID"
        ENV_VARS="$ENV_VARS,REGION=$REGION"
        ENV_VARS="$ENV_VARS,GCS_BUCKET_NAME=duotopia-audio"

        # TapPay ÈÖçÁΩÆÔºàÊ†πÊìöÁí∞Â¢ÉË®≠ÂÆö Sandbox/ProductionÔºâ
        ENV_VARS="$ENV_VARS,TAPPAY_SANDBOX_APP_ID=${{ secrets.TAPPAY_SANDBOX_APP_ID }}"
        ENV_VARS="$ENV_VARS,TAPPAY_SANDBOX_APP_KEY=${{ secrets.TAPPAY_SANDBOX_APP_KEY }}"
        ENV_VARS="$ENV_VARS,TAPPAY_SANDBOX_PARTNER_KEY=${{ secrets.TAPPAY_SANDBOX_PARTNER_KEY }}"
        ENV_VARS="$ENV_VARS,TAPPAY_SANDBOX_MERCHANT_ID=${{ secrets.TAPPAY_SANDBOX_MERCHANT_ID }}"
        ENV_VARS="$ENV_VARS,TAPPAY_PRODUCTION_APP_ID=${{ secrets.TAPPAY_PRODUCTION_APP_ID }}"
        ENV_VARS="$ENV_VARS,TAPPAY_PRODUCTION_APP_KEY=${{ secrets.TAPPAY_PRODUCTION_APP_KEY }}"
        ENV_VARS="$ENV_VARS,TAPPAY_PRODUCTION_PARTNER_KEY=${{ secrets.TAPPAY_PRODUCTION_PARTNER_KEY }}"
        ENV_VARS="$ENV_VARS,TAPPAY_PRODUCTION_MERCHANT_ID=${{ secrets.TAPPAY_PRODUCTION_MERCHANT_ID }}"

        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          ENV_VARS="$ENV_VARS,TAPPAY_ENV=production"
        else
          ENV_VARS="$ENV_VARS,TAPPAY_ENV=production"  # Staging also uses production TapPay
        fi

        ENV_VARS="$ENV_VARS,USE_MOCK_PAYMENT=false"

        # Cron Job ÈÖçÁΩÆ
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          ENV_VARS="$ENV_VARS,CRON_SECRET=${{ secrets.PRODUCTION_CRON_SECRET }}"
        else
          ENV_VARS="$ENV_VARS,CRON_SECRET=${{ secrets.STAGING_CRON_SECRET }}"
        fi

        # Payment ÂäüËÉΩÊéßÂà∂
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          # Production: È†êË®≠Á¶ÅÁî®‰ªòÊ¨æÂäüËÉΩÔºàÂÖçË≤ªÂÑ™ÊÉ†ÊúüÔºâ
          ENV_VARS="$ENV_VARS,ENABLE_PAYMENT=${{ secrets.PRODUCTION_ENABLE_PAYMENT }}"
        else
          # Staging: È†êË®≠ÂïüÁî®‰ªòÊ¨æÂäüËÉΩÔºàÊ∏¨Ë©¶Áî®Ôºâ
          ENV_VARS="$ENV_VARS,ENABLE_PAYMENT=${{ secrets.STAGING_ENABLE_PAYMENT }}"
        fi

        # Ë®≠ÂÆö min-instances = 0 ÊúÄÂ§ßÂåñÁØÄÁúÅÊàêÊú¨
        MIN_INSTANCES=0  # Production Âíå Staging ÈÉΩË®≠ÁÇ∫ 0 ÁØÄÁúÅÊàêÊú¨

        gcloud run deploy ${{ steps.env_vars.outputs.BACKEND_SERVICE }} \
          --image $REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/${{ steps.env_vars.outputs.BACKEND_SERVICE }}:$GITHUB_SHA \
          --platform managed \
          --region $REGION \
          --allow-unauthenticated \
          --port 8080 \
          --memory 512Mi \
          --cpu 1 \
          --max-instances 3 \
          --min-instances $MIN_INSTANCES \
          --cpu-throttling \
          --concurrency 25 \
          --no-cpu-boost \
          --set-env-vars="$ENV_VARS"

    - name: üßπ Cleanup Old Backend Images
      run: |
        echo "üîç Cleaning up old backend container images..."
        KEEP_COUNT=2
        BACKEND_IMAGES=$(gcloud container images list-tags \
          $REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/${{ steps.env_vars.outputs.BACKEND_SERVICE }} \
          --format="value(digest)" \
          --sort-by="~timestamp" 2>/dev/null || echo "")

        if [ ! -z "$BACKEND_IMAGES" ]; then
          TOTAL=$(echo "$BACKEND_IMAGES" | wc -l)
          if [ $TOTAL -gt $KEEP_COUNT ]; then
            TO_DELETE=$(echo "$BACKEND_IMAGES" | tail -n +$((KEEP_COUNT + 1)))
            for DIGEST in $TO_DELETE; do
              echo "  Deleting backend image: $DIGEST"
              gcloud container images delete \
                "$REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/${{ steps.env_vars.outputs.BACKEND_SERVICE }}@sha256:$DIGEST" \
                --force-delete-tags --quiet || true
            done
          fi
        fi

    - name: Health check
      run: |
        BACKEND_URL=$(gcloud run services describe ${{ steps.env_vars.outputs.BACKEND_SERVICE }} --platform managed --region $REGION --format 'value(status.url)')
        echo "üîç Checking backend health at $BACKEND_URL/api/health"

        for i in {1..5}; do
          if curl -f "$BACKEND_URL/api/health" --max-time 10; then
            echo "‚úÖ Backend is healthy!"
            break
          else
            echo "‚è≥ Waiting for backend to be ready (attempt $i/5)..."
            sleep 10
          fi
        done

    - name: üîç Deployment Verification
      run: |
        echo "üîç Verifying deployment success..."

        # 1Ô∏è‚É£ Cloud Run ÈÉ®ÁΩ≤Á¢∫Ë™ç
        echo "üì¶ Checking Cloud Run revision..."
        LATEST_REVISION=$(gcloud run revisions list \
          --service ${{ steps.env_vars.outputs.BACKEND_SERVICE }} \
          --platform managed \
          --region $REGION \
          --limit 1 \
          --format 'value(metadata.name)')

        CREATION_TIME=$(gcloud run revisions describe $LATEST_REVISION \
          --platform managed \
          --region $REGION \
          --format 'value(metadata.creationTimestamp)')

        echo "‚úÖ Latest revision: $LATEST_REVISION"
        echo "‚úÖ Created at: $CREATION_TIME"

        # 2Ô∏è‚É£ ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•
        echo "ü©∫ Checking service health..."
        BACKEND_URL=$(gcloud run services describe ${{ steps.env_vars.outputs.BACKEND_SERVICE }} \
          --platform managed \
          --region $REGION \
          --format 'value(status.url)')

        HEALTH_RESPONSE=$(curl -s "$BACKEND_URL/health" || echo "ERROR")
        if echo "$HEALTH_RESPONSE" | grep -q "healthy"; then
          echo "‚úÖ Health check passed"
          echo "$HEALTH_RESPONSE" | jq '.' || echo "$HEALTH_RESPONSE"
        else
          echo "‚ùå Health check failed: $HEALTH_RESPONSE"
          exit 1
        fi

        # 3Ô∏è‚É£ Áí∞Â¢ÉËÆäÊï∏È©óË≠â
        echo "üîß Verifying environment configuration..."
        if echo "$HEALTH_RESPONSE" | grep -q '"environment": "${{ steps.env_vars.outputs.ENV_NAME }}"'; then
          echo "‚úÖ Environment correctly set to: ${{ steps.env_vars.outputs.ENV_NAME }}"
        else
          echo "‚ö†Ô∏è Environment configuration may not match"
        fi

    - name: Deployment Summary
      run: |
        echo "üéâ Backend deployment completed and verified!"
        echo "üì¶ Environment: ${{ steps.env_vars.outputs.ENV_NAME }}"
        echo "üè∑Ô∏è Version: ${{ github.sha }}"
        BACKEND_URL=$(gcloud run services describe ${{ steps.env_vars.outputs.BACKEND_SERVICE }} --platform managed --region $REGION --format 'value(status.url)')
        echo "üåê Backend URL: $BACKEND_URL"
